#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "board.h"
#include "opening.h"

#define VIOLET_MASK 0x07
#define ORANGE_MASK 0x70
#define VIOLET_EDGE 0x01
#define ORANGE_EDGE 0x10
#define VIOLET_SIDE 0x02
#define ORANGE_SIDE 0x20
#define VIOLET_BLOCK 0x04
#define ORANGE_BLOCK 0x40
#define EFFECT 0x08

struct Edge {
    int x, y, direction;
};

Move::Move(const char* fourcc)
{
    if (fourcc[0] == '-')
	m_ = 0xffff;
    else {
	int xy;
	sscanf(fourcc, "%2X", &xy);
	m_ = (xy - 0x11) |
	    (('u' - tolower(fourcc[2])) & 0x1f) << 11 |
	    (fourcc[3] - '0') << 8;
    }
}

std::string Move::fourcc() const
{
    char buf[5];
    if (is_pass())
	strcpy(buf, "----");
    else
	sprintf(buf, "%2X%c%d",
		(m_ & 0xff) + 0x11, 'u' - block_id(), direction());
    return std::string(buf);
}

Move Move::mirror() const
{
    if (is_pass())
	return PASS;
    int d = (direction() + (direction() & 1 ? 5 : 3)) & 7;
    Rotation* rot = &block_set[block_id()]->rotations[d];
    int new_x = y() + rot->offset_x;
    int new_y = x() + rot->offset_y;
    return Move(new_x, new_y, rot->piece->id);
}

Board::Board()
{
    memset(square, 0, sizeof(square));
    at(START1X, START1Y) = VIOLET_EDGE;
    at(START2X, START2Y) = ORANGE_EDGE;

    turn_ = 0;
    memset(block_info, 0, sizeof(block_info));
}

bool Board::is_valid_move(Move move)
{
    if (move.is_pass())
	return true;

    if (blocks()[move.block_id()])
	return false;

    Rotation* rot = &block_set[move.block_id()]->rotations[move.direction()];
    int px = move.x() + rot->offset_x;
    int py = move.y() + rot->offset_y;
    Piece *piece = rot->piece;

    if (px + piece->minx < 0 || px + piece->maxx >= XSIZE ||
	py + piece->miny < 0 || py + piece->maxy >= YSIZE ||
	!is_movable(px, py, piece))
	return false;

    for (int i = 0; i < piece->size; i++) {
	int x = px + piece->coords[i].x;
	int y = py + piece->coords[i].y;
	if (at(x, y) & (is_violet() ? VIOLET_EDGE : ORANGE_EDGE))
	    return true;
    }
    return false;
}

void Board::do_move(Move move)
{
    if (move.is_pass()) {
	do_pass();
	return;
    }

    Rotation* rot = &block_set[move.block_id()]->rotations[move.direction()];
    int px = move.x() + rot->offset_x;
    int py = move.y() + rot->offset_y;
    Piece *piece = rot->piece;

    unsigned char block = is_violet() ? VIOLET_BLOCK : ORANGE_BLOCK;
    unsigned char side_bit = is_violet() ? VIOLET_SIDE : ORANGE_SIDE;
    unsigned char edge_bit = is_violet() ? VIOLET_EDGE : ORANGE_EDGE;

    for (int i = 0; i < piece->size; i++) {
	int x = px + piece->coords[i].x;
	int y = py + piece->coords[i].y;
	at(x, y) |= block;
	if (in_bounds(x-1, y)) at(x-1, y) |= side_bit;
	if (in_bounds(x, y-1)) at(x, y-1) |= side_bit;
	if (in_bounds(x+1, y)) at(x+1, y) |= side_bit;
	if (in_bounds(x, y+1)) at(x, y+1) |= side_bit;
	if (in_bounds(x-1,y-1)) at(x-1,y-1) |= edge_bit;
	if (in_bounds(x+1,y-1)) at(x+1,y-1) |= edge_bit;
	if (in_bounds(x-1,y+1)) at(x-1,y+1) |= edge_bit;
	if (in_bounds(x+1,y+1)) at(x+1,y+1) |= edge_bit;
    }

    int blk = is_violet() ? move.block_id() : move.block_id() + NBLOCK;
    block_info[blk] = move.xy() + 0x11;
    block_info[NBLOCK*2 + move.block_id()] |=
	is_violet() ? move.direction() : move.direction() << 4;

    turn_++;
}

inline bool Board::move_filter(const Piece *piece)
{
    if (turn() < 8 && piece->size < 5)
	return false;
    else
	return true;
}

bool Board::is_movable(int px, int py, const Piece *piece)
{
    unsigned char mask = is_violet() ? VIOLET_BLOCK|VIOLET_SIDE|ORANGE_BLOCK
				     : ORANGE_BLOCK|ORANGE_SIDE|VIOLET_BLOCK;

    for (int i = 0; i < piece->size; i++) {
	int x = px + piece->coords[i].x;
	int y = py + piece->coords[i].y;
	if (at(x, y) & mask)
	    return false;
    }
    return true;
}

class MoveCollector : public MovableVisitor {
public:
    MoveCollector(Move* a) : movables(a), nmove(0) {}
    virtual bool visit_move(Move m) {
	movables[nmove++] = m;
	return true;
    }
    Move* movables;
    int nmove;
};

int Board::movables(Move* movables)
{
    MoveCollector collector(movables);
    each_movable(&collector);
    return collector.nmove;
}

bool Board::each_movable(MovableVisitor* visitor)
{
    if (turn() < 2) {
	const unsigned short *move = (turn() == 0) ?
	    violet_first_moves : orange_first_moves;
	for (; *move; move++) {
	    Move m(*move);
	    if (move_filter(block_set[m.block_id()]->
			    rotations[m.direction()].piece))
	    {
		if (!visitor->visit_move(m))
		    return false;
	    }
	}
	return true;
    }

    Edge edges[100], *pedge;
    {
	unsigned char edge_mask = is_violet()
	    ? VIOLET_MASK | ORANGE_BLOCK
	    : ORANGE_MASK | VIOLET_BLOCK;
	unsigned char edge_bit = is_violet() ? VIOLET_EDGE : ORANGE_EDGE;
	unsigned char side_bit = is_violet() ? VIOLET_SIDE : ORANGE_SIDE;

	pedge = edges;
	for (int ey = 0; ey < YSIZE; ey++) {
	    for (int ex = 0; ex < XSIZE; ex++) {
		if ((at(ex, ey) & edge_mask) == edge_bit) {
		    pedge->x = ex;
		    pedge->y = ey;
		    pedge->direction = (ey > 0 && at(ex, ey-1) & side_bit)
			? (ex > 0 && (at(ex-1, ey) & side_bit) ? 0 : 1)
			: (ex > 0 && (at(ex-1, ey) & side_bit) ? 2 : 3);
		    pedge++;
		}
	    }
	}
	pedge->x = -1;
    }

    int nmove = 0;
    for (int blk = 0; blk < NBLOCK; blk++) {
	if (blocks()[blk])
	    continue;
	Block* block = block_set[blk];
	for (Piece **variation = block->variations; *variation; variation++) {
	    if (!move_filter(*variation))
		continue;
	    short checked[YSIZE];
	    memset(checked, 0, sizeof(checked));
	    for (pedge = edges; pedge->x >= 0; pedge++) {
		for (int i = 0; i < (*variation)->nedge[pedge->direction]; i++) {
		    int x = pedge->x - (*variation)->edges[pedge->direction][i].x;
		    int y = pedge->y - (*variation)->edges[pedge->direction][i].y;
		    if (y + (*variation)->miny < 0 ||
			y + (*variation)->maxy >= YSIZE ||
			x + (*variation)->minx < 0 ||
			x + (*variation)->maxx >= XSIZE ||
			(checked[y] & 1 << x))
			continue;
		    checked[y] |= 1 << x;
		    if (is_movable(x, y, *variation)) {
			if (!visitor->visit_move(Move(x, y, (*variation)->id)))
			    return false;
			nmove++;
		    }
		}
	    }
	}
    }
    if (nmove == 0)
	return visitor->visit_move(PASS);

    return true;
}

int Board::calc_score(const unsigned char* blks_vec) const
{
    int score = 0;

    for (int i = 0; i < NBLOCK; i++) {
	if (blks_vec[i])
	    score += block_set[i]->size;
    }
    return score;
}

int Board::eval_blocks() const
{
    const int table[NBLOCK] = {
	16,16,16,16,16,16,16,16,16,16,16,16, 10,10,10,10,10, 6,6, 4, 2
    };
    int score = 0;

    for (int i = 0; i < NBLOCK; i++) {
	if (block_info[i] == 0)
	    score -= table[i];
	if (block_info[NBLOCK + i] == 0)
	    score += table[i];
    }
    return score;
}

int Board::eval_effect() const
{
    unsigned char b[16*15];
    unsigned char *edges[2][YSIZE*XSIZE], **pedge, **pnew_edge;
    int score = 0;

    for (int x = 0; x <= XSIZE; x++)
	b[x] = VIOLET_BLOCK|ORANGE_BLOCK;
    for (int y = 0; y <= YSIZE; y++)
	b[y*15+XSIZE] = VIOLET_BLOCK|ORANGE_BLOCK;
    for (int x = 0; x <= XSIZE; x++)
	b[225+x] = VIOLET_BLOCK|ORANGE_BLOCK;

    for (int player = 0; player < 2; player++) {
	const unsigned char mask[2] = { VIOLET_MASK|ORANGE_BLOCK,
					ORANGE_MASK|VIOLET_BLOCK };
	const unsigned char edge[2] = { VIOLET_EDGE, ORANGE_EDGE };

	pedge = edges[0];
	for (int y = 0; y < YSIZE; y++) {
	    for (int x = 0; x < XSIZE; x++) {
		b[(y+1)*15+x] = at(x,y) & mask[player];
		if (b[(y+1)*15+x] == edge[player]) {
		    *pedge++ = &b[(y+1)*15+x];
		    score++;
		}
	    }
	}
	*pedge = NULL;

	pedge     = edges[0];
	pnew_edge = edges[1];
	while (*pedge) {
	    unsigned char* pos = *pedge++;
	    if (pos[-15] == 0) {
		pos[-15] = 1;
		*pnew_edge++ = pos-15;
		score++;
	    }
	    if (pos[-1] == 0) {
		pos[-1] = 1;
		*pnew_edge++ = pos-1;
		score++;
	    }
	    if (pos[1] == 0) {
		pos[1] = 1;
		*pnew_edge++ = pos+1;
		score++;
	    }
	    if (pos[15] == 0) {
		pos[15] = 1;
		*pnew_edge++ = pos+15;
		score++;
	    }
	}
	*pnew_edge = NULL;

	pedge     = edges[1];
	pnew_edge = edges[0];
	while (*pedge) {
	    unsigned char* pos = *pedge++;
	    if (pos[-15] == 0) {
		pos[-15] = 1;
		*pnew_edge++ = pos-15;
		score++;
	    }
	    if (pos[-1] == 0) {
		pos[-1] = 1;
		*pnew_edge++ = pos-1;
		score++;
	    }
	    if (pos[1] == 0) {
		pos[1] = 1;
		*pnew_edge++ = pos+1;
		score++;
	    }
	    if (pos[15] == 0) {
		pos[15] = 1;
		*pnew_edge++ = pos+15;
		score++;
	    }
	}
	*pnew_edge = NULL;

	pedge = edges[0];
	while (*pedge) {
	    unsigned char* pos = *pedge++;
	    if (pos[-15] == 0) {
		pos[-15] = 1;
		score++;
	    }
	    if (pos[-1] == 0) {
		pos[-1] = 1;
		score++;
	    }
	    if (pos[1] == 0) {
		pos[1] = 1;
		score++;
	    }
	    if (pos[15] == 0) {
		pos[15] = 1;
		score++;
	    }
	}

	score = -score;
    }
    return score;
}

std::string Board::to_str()
{
    std::string s(YSIZE * (XSIZE + 1), ' ');
    int i = 0;
    for (int y = 0; y < YSIZE; y++) {
	for (int x = 0; x < XSIZE; x++) {
	    unsigned char c = at(x, y);
	    if (c & VIOLET_BLOCK)
		s[i++] = '1';
	    else if (c & ORANGE_BLOCK)
		s[i++] = '2';
	    else
		s[i++] = '.';
	}
	s[i++] = '\n';
    }
    return s;
}

std::string Board::pieces()
{
    char buf[100];
    char* p = buf;

    for (int player = 0; player < 2; player++) {
	bool first = true;
	for (int b = NBLOCK-1; b >= 0; b--) {
	    if (block_info[b + player * NBLOCK] == 0) {
		if (!first)
		    *p++ = ' ';
		first = false;
		*p++ = block_set[b]->name();
	    }
	}
	*p++ = '\n';
    }
    *p = '\0';
    return std::string(buf);
}
